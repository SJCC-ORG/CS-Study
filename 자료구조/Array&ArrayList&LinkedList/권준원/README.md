# Array&ArrayList&LinkedList

## Array

### 배열이란

- 같은 데이터 타입의 변수들로 이루어진 자료구조이다.
- 요소 혹은 원소(element)는 배열을 구성하는 각각의 값이다.
- 인덱스(index)는 배열에서 위치를 가르키는 숫자이다.
- 대부분의 언어에서 배열의 인덱스는 0부터 시작한다.
- 배열은 참조 객체이므로 배열을 가르키는 참조 변수는 스택 영역에 할당되며, 참조 변수가 가르키고 있는 주소값은 실제 힙 영역에 생성되는 배열의 주소값이다.

### 배열의 특징

- 선언하는 순간에 크기가 정해지면 변경할 수 없다.
    - 크기가 고정적이다.
- 배열의 물리 주소와 논리 주소는 동일하다.
    
    ```c
    #include<stdio.h>
    int main() {
    	int arr[5] = {1, 2, 3, 4, 5};
    	
    	printf("주소값 출력\n");
    	printf("%x\n", &arr[0]);
    	printf("%x\n", &arr[1]);
    	printf("%x\n", &arr[2]);
    	printf("%x\n", &arr[3]);
    	printf("%x\n", &arr[4]);
    
    	// 주소값 출력
    	// efbff430
    	// efbff434
    	// efbff438
    	// efbff43c
    	// efbff440
    }
    ```
    
    - int형 배열의 경우 자료형의 크기가 4byte이기 때문에 4씩 증가하면서 메모리에 저장되고 있음을 알 수 있다.
- 메모리 공간이 연속적으로 구성된다.
    - 덕분에 인덱스를 사용하여 쉽게 접근할 수 있다.

### 배열의 장점

- 인덱스를 이용하여 바로 원소에 접근할 수 있기 때문에 인덱스를 알고 있다면 접근에 걸리는 시간복잡도는 O(1)이다.
- 인덱스를 이용한 접근이 쉽기 때문에 특정 원소에 대한 수정 또한 쉽다.
    - 접근과 마찬가지로 인덱스를 알고 있다면 O(1)의 시간복잡도를 갖는다.

### 배열의 단점

- 크기가 고정적이다.
    - 더 큰 크기의 배열이 필요할 경우 새로운 배열을 만든 후 기존 값들을 모두 복사해야 한다.
    - 모든 데이터를 복사하는데는 O(n)의 시간복잡도가 걸리므로 비효율적이다.
- 배열 중간에 있는 원소를 삭제하거나 삽입할 경우 기존에 존재하던 값들을 옮겨주어야 한다.
    - 배열 중간에 있는 원소를 삭제하고 값들을 옮기지 않을 경우 삭제한 위치에 원하지 않는 값(혹은 flag값)이 들어가게 된다.
        - 배열은 연속적인 주소 공간이기 때문에 비어있을 수 없다.
    - 이는 메모리 낭비이며, 실수로 인해 원치 않는 결과를 불러올 수도 있다.
    - 기존 값들을 옮기지 않고 배열 중간에 원소를 삽입할 경우 기존 값을 덮어쓰게 된다.
    - 이는 데이터 손실로 이어지고 버그를 유발할 수 있다.
        - 데이터가 날아가면 마음이 아프다.
    - 최대 n-1개의 원소를 옮길 수 있으므로 O(n)의 시간복잡도를 갖는다.

## ArrayList

### 배열리스트란

- 내부적으로 배열을 이용하여 요소를 저장하는 자료구조이다.
- 고정된 크기를 갖는 배열의 단점을 극복할 수 있다.

### 배열리스트의 특징

- 배열의 크기를 지정하지 않아도 되고, 관리하지 않아도 된다.
    - 구현체가 리스트의 중간에 빈 공간이 없도록 크기를 조정해준다.
- 저장 공간 크기가 가변적이다.
    - 하지만 내부적으로 배열을 사용하기 때문에 배열의 시간복잡도와 동일한 시간복잡도를 갖는다.
- 내부적으로 배열을 사용하기 때문에 물리 공간과 논리 공간이 동일하며 인덱스를 활용할 수 있다.
    - 인덱스를 활용하기 위해서 `get()`, `set()` 메서드를 사용해야 한다.

### 배열리스트의 장점

- 인덱스를 사용할 수 있으므로 인덱스를 알고 있다면 O(1) 시간에 접근 및 수정이 가능하다.
- 저장 공간이 가변적이므로 저장 공간 크기에 신경쓰지 않아도 된다.
    - 하지만 내부적으로 배열을 이용하기 때문에 배열의 시간복잡도와 차이가 없다.
- 메서드를 이용한 원소의 삽입, 삭제가 쉽다.
    - 마찬가지로 삽입과 삭제에 걸리는 시간은 배열의 시간복잡도와 차이가 없다.
- List 인터페이스

### 배열리스트의 단점

- 삽입, 삭제시 배열의 시간복잡도와 같은 O(n)의 시간복잡도를 갖는다.
- 리스트의 크기 확장시 배열의 시간복잡도와 같은 O(n)의 시간복잡도를 갖는다.

## LinkedList

### 연결리스트란

- 연결리스트는 여러 개의 노드가 연결된 형태의 자료구조이다.
- 연결리스트의 종류로 단일연결리스트, 이중연결리스트, 원형연결리스트 등이 있다.
    - 자바에서 LinkedList 클래스는 이중연결리스트로 만들어져 있다.

### 연결리스트의 특징

- 배열리스트와 마찬가지로 가변적인 크기를 갖는다.
    - 크기를 관리하는데 신경쓰지 않아도 된다.
- 물리 공간과 논리 공간이 일치하지 않는다.
- 메모리 공간이 연속적이지 않다.
    - 따라서 인덱스를 활용할 수 없다.
    - 하지만 자바에서 `get()`, `set()` 메서드를 활용하여 특정 값에 접근할 수 있는데 이는 인덱스가 아닌 특정 노드에 접근하는 것이다.

### 연결리스트의 장점

- 배열처럼 연속된 저장 공간을 사용하는 것이 아닌 노드를 이용하기 때문에 삽입, 삭제 작업에 O(1)의 시간복잡도를 갖는다.
    - 삽입과 삭제를 위하여 다음 노드와 이전 노드의 링크 참조만 바꿔주면 된다.
- 원소를 삽입하거나 삭제할 때 저장 공간을 확장하거나 축소하여 재할당해줄 필요가 없다.
    - 마찬가지로 다음 노드와 이전 노드의 링크만 수정하면 된다.
    - 자바의 경우 GC가 빈 배열을 수거하지 않아도 된다는 장점도 있다.

### 연결리스트의 단점

- 특정 원소에 접근하는 시간복잡도는 O(n)이다.
    - 인덱스를 이용하는 배열과 달리 연결리스트는 링크 참조를 따라 탐색해야 하기 때문이다.
- 특정 원소를 수정하는데 걸리는 시간복잡도도 O(n)이다.
    - 접근하는데 O(n) 시간이 걸리므로
- 연결리스트 중간에 원소를 삽입하거나 삭제할 경우에도 O(n)의 시간복잡도를 갖는다.
    - 삽입, 삭제 작업에 걸리는 시간은 O(1)이지만 특정 원소를 찾아가는데 O(n)의 시간이 걸리기 때문이다.

## Usage

- 고정된 크기의 데이터에 대한 접근, 수정이 잦은 경우 : 배열, 배열리스트
- 데이터의 삽입, 삭제가 잦은 경우 : 연결리스트
